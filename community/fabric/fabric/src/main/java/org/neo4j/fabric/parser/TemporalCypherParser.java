/*
 * Copyright (c) "Neo4j"
 * Neo4j Sweden AB [http://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Neo4j is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
/* TemporalCypherParser.java */
/* Generated By:JavaCC: Do not edit this line. TemporalCypherParser.java */

package org.neo4j.fabric.parser;

import org.apache.commons.lang3.tuple.ImmutableTriple;
import org.apache.commons.lang3.tuple.Triple;

public class TemporalCypherParser implements TemporalCypherParserConstants {

    public static void main(String[] args) throws ParseException, TokenMgrError {
        var parser = new TemporalCypherParser(new java.io.StringReader(args[0]));
        var struct = parser.start();
        System.out.println(struct);
    }

    public static ProcedureStruct parse(String statement) throws ParseException, TokenMgrError {
        var parser = new TemporalCypherParser(new java.io.StringReader(statement));
        return parser.start();
    }

    public final ProcedureStruct start() throws ParseException, TokenMgrError {
        String graphName;
        long systemStartTime;
        long systemEndTime;
        ProcedureStruct struct;
        Triple<Long, Long, Long> whereResult;
        long entityId;
        long applicationStartTime;
        long applicationEndTime;
        int type;
        jj_consume_token(USE);
        graphName = getName();
        jj_consume_token(FOR);
        jj_consume_token(SYSTEM_TIME);
        switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
            case AS_OF: {
                jj_consume_token(AS_OF);
                systemStartTime = getLong();
                systemEndTime = systemStartTime;
                break;
            }
            case FROM: {
                jj_consume_token(FROM);
                systemStartTime = getLong() + 1;
                jj_consume_token(TO);
                systemEndTime = getLong() - 1;
                break;
            }
            case CONTAINED: {
                jj_consume_token(CONTAINED);
                jj_consume_token(IN);
                jj_consume_token(LPAR);
                systemStartTime = getLong();
                jj_consume_token(COMMA);
                systemEndTime = getLong();
                jj_consume_token(RPAR);
                break;
            }
            default:
                jj_la1[0] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
        }
        struct = matchClause();
        whereResult = whereClause(struct.dbName());
        jj_consume_token(0);
        entityId = whereResult.getLeft();
        applicationStartTime = whereResult.getMiddle();
        applicationEndTime = whereResult.getRight();
        type = (entityId == -1) ? (struct.type() + 3) : struct.type();
        if (systemStartTime > systemEndTime) {
            {
                if (true)
                    throw new TokenMgrError(
                            String.format(
                                    "System start time is greater than end time: %s > %s",
                                    systemStartTime, systemEndTime),
                            -1);
            }
        }

        {
            if ("" != null)
                return new ProcedureStruct(
                        graphName,
                        type,
                        entityId,
                        struct.hops(),
                        struct.direction(),
                        systemStartTime,
                        systemEndTime,
                        applicationStartTime,
                        applicationEndTime);
        }
        throw new Error("Missing return statement in function");
    }

    public final long getLong() throws ParseException, NumberFormatException {
        Token t;
        t = jj_consume_token(NUMBER);
        {
            if ("" != null) return Long.parseLong(t.image);
        }
        throw new Error("Missing return statement in function");
    }

    public final String getName() throws ParseException, NumberFormatException {
        Token t;
        t = jj_consume_token(NAME);
        {
            if ("" != null) return t.image;
        }
        throw new Error("Missing return statement in function");
    }

    public final ProcedureStruct matchClause() throws ParseException {
        Triple<String, Integer, Integer> triple = new ImmutableTriple<>("", 0, 0);
        String variableName;
        int type;
        jj_consume_token(MATCH);
        jj_consume_token(LPAR);
        switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
            case RPAR: {
                jj_consume_token(RPAR);
                triple = relationshipExpression();
                jj_consume_token(LPAR);
                jj_consume_token(RPAR);
                type = 0;
                variableName = triple.getLeft();
                break;
            }
            case NAME: {
                variableName = getName();
                type = 1;
                jj_consume_token(RPAR);
                switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
                    case 31:
                    case 34: {
                        triple = relationshipExpression();
                        variableName = nodeExpression();
                        type = 2;
                        break;
                    }
                    default:
                        jj_la1[1] = jj_gen;
                        ;
                }
                break;
            }
            default:
                jj_la1[2] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
        }
        {
            if ("" != null)
                return new ProcedureStruct(
                        variableName, type, -1L, triple.getMiddle(), triple.getRight(), -1L, -1L, -1L, -1L);
        }
        throw new Error("Missing return statement in function");
    }

    public final Triple<String, Integer, Integer> relationshipExpression() throws ParseException {
        String name;
        long hops = 1;
        int direction;
        switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
            case 31: {
                jj_consume_token(31);
                jj_consume_token(LBRACKET);
                name = getName();
                switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
                    case 32: {
                        jj_consume_token(32);
                        hops = getLong();
                        break;
                    }
                    default:
                        jj_la1[3] = jj_gen;
                        ;
                }
                jj_consume_token(RBRACKET);
                switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
                    case 31: {
                        jj_consume_token(31);
                        direction = 0;
                        break;
                    }
                    case 33: {
                        jj_consume_token(33);
                        direction = 1;
                        break;
                    }
                    default:
                        jj_la1[4] = jj_gen;
                        jj_consume_token(-1);
                        throw new ParseException();
                }
                break;
            }
            case 34: {
                jj_consume_token(34);
                direction = -1;
                jj_consume_token(LBRACKET);
                name = getName();
                switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
                    case 32: {
                        jj_consume_token(32);
                        hops = getLong();
                        break;
                    }
                    default:
                        jj_la1[5] = jj_gen;
                        ;
                }
                jj_consume_token(RBRACKET);
                jj_consume_token(31);
                break;
            }
            default:
                jj_la1[6] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
        }
        {
            if ("" != null) return new ImmutableTriple<>(name, (int) hops, direction);
        }
        throw new Error("Missing return statement in function");
    }

    public final String nodeExpression() throws ParseException {
        String variableName;
        jj_consume_token(LPAR);
        variableName = getName();
        jj_consume_token(RPAR);
        {
            if ("" != null) return variableName;
        }
        throw new Error("Missing return statement in function");
    }

    public final Triple<Long, Long, Long> whereClause(String variableName) throws ParseException, TokenMgrError {
        long entityId;
        String filterName = "";
        String result;
        long startTime = -1;
        long endTime = -1;
        switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
            case WHERE: {
                jj_consume_token(WHERE);
                switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
                    case ID: {
                        jj_consume_token(ID);
                        jj_consume_token(LPAR);
                        filterName = getName();
                        jj_consume_token(RPAR);
                        jj_consume_token(EQUALS);
                        entityId = getLong();
                        break;
                    }
                    case APPLICATION_TIME: {
                        jj_consume_token(APPLICATION_TIME);
                        switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
                            case FROM: {
                                jj_consume_token(FROM);
                                startTime = getLong() + 1;
                                jj_consume_token(TO);
                                endTime = getLong() - 1;
                                break;
                            }
                            case CONTAINED: {
                                jj_consume_token(CONTAINED);
                                jj_consume_token(IN);
                                jj_consume_token(LPAR);
                                startTime = getLong();
                                jj_consume_token(COMMA);
                                endTime = getLong();
                                jj_consume_token(RPAR);
                                break;
                            }
                            default:
                                jj_la1[7] = jj_gen;
                                jj_consume_token(-1);
                                throw new ParseException();
                        }
                        entityId = -1;
                        break;
                    }
                    default:
                        jj_la1[8] = jj_gen;
                        jj_consume_token(-1);
                        throw new ParseException();
                }
                jj_consume_token(RETURN);
                result = getName();
                break;
            }
            case RETURN: {
                jj_consume_token(RETURN);
                result = getName();
                entityId = -1;
                break;
            }
            default:
                jj_la1[9] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
        }
        if (!result.equalsIgnoreCase(variableName)) {
            {
                if (true)
                    throw new TokenMgrError(String.format("Wrong return value: %s != %s", result, variableName), -1);
            }
        }
        if (startTime > endTime) {
            {
                if (true)
                    throw new TokenMgrError(
                            String.format("Start time is greater than end time: %s > %s", startTime, endTime), -1);
            }
        }
        {
            if ("" != null) return Triple.of(entityId, startTime, endTime);
        }
        throw new Error("Missing return statement in function");
    }

    /** Generated Token Manager. */
    public TemporalCypherParserTokenManager token_source;

    SimpleCharStream jj_input_stream;
    /** Current token. */
    public Token token;
    /** Next token. */
    public Token jj_nt;

    private int jj_ntk;
    private int jj_gen;
    private final int[] jj_la1 = new int[10];
    private static int[] jj_la1_0;
    private static int[] jj_la1_1;

    static {
        jj_la1_init_0();
        jj_la1_init_1();
    }

    private static void jj_la1_init_0() {
        jj_la1_0 = new int[] {
            0x2c00000, 0x80000000, 0x10001000, 0x0, 0x80000000, 0x0, 0x80000000, 0x2800000, 0x220000, 0x300,
        };
    }

    private static void jj_la1_init_1() {
        jj_la1_1 = new int[] {
            0x0, 0x4, 0x0, 0x1, 0x2, 0x1, 0x4, 0x0, 0x0, 0x0,
        };
    }

    /** Constructor with InputStream. */
    public TemporalCypherParser(java.io.InputStream stream) {
        this(stream, null);
    }
    /** Constructor with InputStream and supplied encoding */
    public TemporalCypherParser(java.io.InputStream stream, String encoding) {
        try {
            jj_input_stream = new SimpleCharStream(stream, encoding, 1, 1);
        } catch (java.io.UnsupportedEncodingException e) {
            throw new RuntimeException(e);
        }
        token_source = new TemporalCypherParserTokenManager(jj_input_stream);
        token = new Token();
        jj_ntk = -1;
        jj_gen = 0;
        for (int i = 0; i < 10; i++) jj_la1[i] = -1;
    }

    /** Reinitialise. */
    public void ReInit(java.io.InputStream stream) {
        ReInit(stream, null);
    }
    /** Reinitialise. */
    public void ReInit(java.io.InputStream stream, String encoding) {
        try {
            jj_input_stream.ReInit(stream, encoding, 1, 1);
        } catch (java.io.UnsupportedEncodingException e) {
            throw new RuntimeException(e);
        }
        token_source.ReInit(jj_input_stream);
        token = new Token();
        jj_ntk = -1;
        jj_gen = 0;
        for (int i = 0; i < 10; i++) jj_la1[i] = -1;
    }

    /** Constructor. */
    public TemporalCypherParser(java.io.Reader stream) {
        jj_input_stream = new SimpleCharStream(stream, 1, 1);
        token_source = new TemporalCypherParserTokenManager(jj_input_stream);
        token = new Token();
        jj_ntk = -1;
        jj_gen = 0;
        for (int i = 0; i < 10; i++) jj_la1[i] = -1;
    }

    /** Reinitialise. */
    public void ReInit(java.io.Reader stream) {
        if (jj_input_stream == null) {
            jj_input_stream = new SimpleCharStream(stream, 1, 1);
        } else {
            jj_input_stream.ReInit(stream, 1, 1);
        }
        if (token_source == null) {
            token_source = new TemporalCypherParserTokenManager(jj_input_stream);
        }

        token_source.ReInit(jj_input_stream);
        token = new Token();
        jj_ntk = -1;
        jj_gen = 0;
        for (int i = 0; i < 10; i++) jj_la1[i] = -1;
    }

    /** Constructor with generated Token Manager. */
    public TemporalCypherParser(TemporalCypherParserTokenManager tm) {
        token_source = tm;
        token = new Token();
        jj_ntk = -1;
        jj_gen = 0;
        for (int i = 0; i < 10; i++) jj_la1[i] = -1;
    }

    /** Reinitialise. */
    public void ReInit(TemporalCypherParserTokenManager tm) {
        token_source = tm;
        token = new Token();
        jj_ntk = -1;
        jj_gen = 0;
        for (int i = 0; i < 10; i++) jj_la1[i] = -1;
    }

    private Token jj_consume_token(int kind) throws ParseException {
        Token oldToken;
        if ((oldToken = token).next != null) token = token.next;
        else token = token.next = token_source.getNextToken();
        jj_ntk = -1;
        if (token.kind == kind) {
            jj_gen++;
            return token;
        }
        token = oldToken;
        jj_kind = kind;
        throw generateParseException();
    }

    /** Get the next Token. */
    public final Token getNextToken() {
        if (token.next != null) token = token.next;
        else token = token.next = token_source.getNextToken();
        jj_ntk = -1;
        jj_gen++;
        return token;
    }

    /** Get the specific Token. */
    public final Token getToken(int index) {
        Token t = token;
        for (int i = 0; i < index; i++) {
            if (t.next != null) t = t.next;
            else t = t.next = token_source.getNextToken();
        }
        return t;
    }

    private int jj_ntk_f() {
        if ((jj_nt = token.next) == null) return (jj_ntk = (token.next = token_source.getNextToken()).kind);
        else return (jj_ntk = jj_nt.kind);
    }

    private java.util.List<int[]> jj_expentries = new java.util.ArrayList<int[]>();
    private int[] jj_expentry;
    private int jj_kind = -1;

    /** Generate ParseException. */
    public ParseException generateParseException() {
        jj_expentries.clear();
        boolean[] la1tokens = new boolean[35];
        if (jj_kind >= 0) {
            la1tokens[jj_kind] = true;
            jj_kind = -1;
        }
        for (int i = 0; i < 10; i++) {
            if (jj_la1[i] == jj_gen) {
                for (int j = 0; j < 32; j++) {
                    if ((jj_la1_0[i] & (1 << j)) != 0) {
                        la1tokens[j] = true;
                    }
                    if ((jj_la1_1[i] & (1 << j)) != 0) {
                        la1tokens[32 + j] = true;
                    }
                }
            }
        }
        for (int i = 0; i < 35; i++) {
            if (la1tokens[i]) {
                jj_expentry = new int[1];
                jj_expentry[0] = i;
                jj_expentries.add(jj_expentry);
            }
        }
        int[][] exptokseq = new int[jj_expentries.size()][];
        for (int i = 0; i < jj_expentries.size(); i++) {
            exptokseq[i] = jj_expentries.get(i);
        }
        return new ParseException(token, exptokseq, tokenImage);
    }

    private boolean trace_enabled;

    /** Trace enabled. */
    public final boolean trace_enabled() {
        return trace_enabled;
    }

    /** Enable tracing. */
    public final void enable_tracing() {}

    /** Disable tracing. */
    public final void disable_tracing() {}
}
